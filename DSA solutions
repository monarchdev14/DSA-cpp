BINARY SEARCH
class Solution {
  public:
    int binarysearch(vector<int> &arr, int k) {
        // code here
        int s = 0;
        int e = arr.size() - 1;
        int result = -1;
        while (s <= e) {
            int mid = s + (e - s) / 2;

            if (arr[mid] == k) {
                result = mid;   
                e = mid - 1;    
            } 
            else if (arr[mid] > k) {
                e = mid - 1;   
            } 
            else {
                s = mid + 1;   
            }
        }

        return result;
    }
};
ARRAY DUPLICATES
class Solution {
  public:
    vector<int> findDuplicates(vector<int>& arr) {
        // code here
        vector<int>result;
        sort(arr.begin(), arr.end());
        int n=arr.size();
        int leader=arr[n-1];
        for(int i=n-2; i>=0; i--){
            if(arr[i]==leader){
                result.push_back(leader);
                leader=arr[i];
            }
            if(arr[i]!=leader){
                leader=arr[i];
            }
        }
        reverse(result.begin(), result.end());
        return result;
    }
};
ARRAY reverse
class Solution {
  public:
    void helper_func(vector<int> &arr, int m_n, int i, int j){
        if(i>=j){
            return ;
        }
        swap(arr[i], arr[j]);
        i++;
        j--;
        helper_func(arr,m_n,i,j);
    }
    void reverseArray(vector<int> &arr) {
        // code here
        int n= arr.size();
        int i=0;
        int m_n=n/2;
        int j= n-1;
        helper_func(arr, m_n, i, j);
    }
};
EQUILIBRIUM POINT
class Solution {
  public:
    // Function to find equilibrium point in the array.
    int findEquilibrium(vector<int> &arr) {
        // code here
        int total_size=0;
        for(int i=0; i<arr.size(); i++){
            total_size+=arr[i];
        }
        int i=0;
        int left_sum=0;
        int right_sum=0;
        int current_element;
        while(i<arr.size()){
            left_sum+=arr[i];
            current_element=arr[i+1];
            right_sum=total_size-left_sum-current_element;
            if(left_sum==right_sum){
                return i+1;
            }
            i++;
        }
        return -1;
    }
};
ARRAY LEADERS


class Solution {
    // Function to find the leaders in the array.
  public:
    vector<int> leaders(vector<int>& arr) {
        // Code here
        int n=arr.size();
        int leader=arr[n-1];
        vector<int> v;
        v.push_back(leader);
        for(int i=n-2; i>=0; i--){
            if(arr[i]>=leader){
                leader=arr[i];
                v.push_back(leader);
            }
        }
        reverse(v.begin(), v.end());
        return v;
    }
};
SORTED AND ROTATED MEDIUM
class Solution {
  public:
    int findMin(vector<int>& arr) {
        // complete the function here
        int s=0; int e=arr.size()-1;
        int m=s+(e-s)/2;
        if(arr[s]<arr[e]){
            return arr[s];
        }
        if(arr[s]<=arr[m]){
            s=m;
            int min=arr[s];
            for(int i=s+1; i<=e; i++){
                if(arr[i]<min){
                    min=arr[i];
                }
            }
            return min;
        }
        if(arr[s]>=arr[m]){
            e=m;
            int min=arr[s];
            for(int i=s+1; i<=e; i++){
                if(arr[i]<min){
                    min=arr[i];
                }
            }
            return min;
        }
    }
};
REMOVE CONSECUTIVE CHARACTERS
class Solution {
  public:
    void helper_func(string &s, int i){
        if(i>=s.size()-1){
            return;
        }
        if(s[i]==s[i+1]){
            s.erase(s.begin()+i+1);
            i=i-1;
        }
        helper_func(s,i+1);
    }
    string removeConsecutiveCharacter(string& s) {
        // code here.
        int i=0;
        helper_func(s,i);
        return s;
    }
};
SECOND LARGEST
class Solution {
  public:
    int helper_func(vector<int> &arr, int max, int i){
        if(arr[i+1]==max){
            return arr[i];
        }
        helper_func(arr, max, i+1);
    }
    int getSecondLargest(vector<int> &arr) {
        // code here
        sort(arr.begin(), arr.end());
        int max=arr[arr.size()-1];
        if(arr[0]==max){
            return -1;
        }else{
            return helper_func(arr,max,0);
        }
    }
};
CHECK IF ARRAY IS SORTED
class Solution {
  public:
  bool helper_func(vector<int> &arr, int i){
    if(i == arr.size() - 1){
        return true;   // base case
    }

    if(arr[i] > arr[i + 1]){
        return false;
    }

    return helper_func(arr, i + 1);
}
    bool isSorted(vector<int>& arr) {
        // code here
        int i=0;
        helper_func(arr,i);
    }
};
PALINDROME string
class Solution {
  public:
    bool helper_func(string &s, int i, int j){
    if(i>=j){
        return true;
    }
    if(s[i]!=s[j]){
        return false;
    }
    helper_func(s,i+1,j-1);
}
    bool isPalindrome(string& s) {
        // code here
        int i=0; int j= s.size()-1;
        return helper_func(s,i,j);
    }
};
MAX SUBARRAY OF SIZE K 
class Solution {
  public:
    int maxSubarraySum(vector<int>& arr, int k) {
        // code here
        int n=arr.size();
        if(n<k){
            return 0;
        }
        int sub_sum=0;
        for(int i=0; i<k; i++){
            sub_sum+=arr[i];
        }
        int max_sum=sub_sum;
        for(int i=k; i<n; i++){
            sub_sum+=(arr[i]-arr[i-k]);
            max_sum=max(max_sum,sub_sum);
        }
        return max_sum;
    }
};
MIN AND MAX IN ARRA 
class Solution {
  public:
      void max_min(vector<int> &arr, int i, int j, int max, int min, vector<int> &v){
    	if(i>arr.size()-1 && j<0){
    		v.push_back(min);
    		v.push_back(max);
    		return;
    	}
    	if(arr[i]<min){
    		min=arr[i];
    	}
    	if(arr[j]>max){
    		max=arr[j];
    	}
    	max_min(arr,i+1,j-1,max,min,v);
    }
    vector<int> getMinMax(vector<int> &arr) {
        // code here
        vector<int> v;
    	int i=1; int j=arr.size()-2;
    	int min=arr[0];
    	int max=arr[arr.size()-1];
    	max_min(arr,i,j,max,min,v);
    	return v;
    }
};
REVERSE A STRING WITHOUT RECURSION
// User function Template for C++
class Solution {
  public:
    string revStr(string s) {
        // code here
        reverse(s.begin(), s.end());
        return s;
    }
};
MERGE SORT
class Solution {
  public:
    void merge(vector<int> &arr, int l, int r){
        int i=l;
        int mid=l+(r-l)/2;
        int j=mid+1;
        vector<int> temp;
        while(i<=mid && j<=r){
            if(arr[i]<arr[j]){
                temp.push_back(arr[i]);
                i++;
            }else{
                temp.push_back(arr[j]);
                j++;
            }
        }
        while(i<=mid){
            temp.push_back(arr[i]);
            i++;
        }
        while(j<=r){
            temp.push_back(arr[j]);
            j++;
        }
        int k=0;
        for(int idx=l; idx<=r; idx++){
            arr[idx]=temp[k];
            k++;
        }
        return;
    }
    void mergeSort(vector<int>& arr, int l, int r) {
        // code here
        if(l>=r){
            return;
        }
        int mid=l+(r-l)/2;
        mergeSort(arr,l,mid);
        mergeSort(arr,mid+1,r);
        merge(arr,l,r);
    }
};
QUICK SORT
class Solution {
  public:
    void quickSort(vector<int>& arr, int low, int high) {
        // code here
        if(low<high){
            int pivIdx=partition(arr,low,high);
            quickSort(arr,low,pivIdx-1);
            quickSort(arr,pivIdx+1,high);
        }
    }

  public:
    int partition(vector<int>& arr, int low, int high) {
        
        // code here
        int idx=low-1;
        int piv=arr[high];
        for(int j=low; j<high; j++){
            if(arr[j]<=piv){
                idx++;
                swap(arr[idx],arr[j]);
            }
        }
        idx++;
        swap(arr[idx],arr[high]);
        return idx;
    }
};
RAT IN A MAZE 
class Solution {
  public:
    vector<int> dx={1,0,-1,0};
    vector<int> dy={0,1,0,-1};
    vector<char> directions={'D','R','U','L'};
    void ratandmice(int row, int col, vector<vector<int>> &maze, vector<vector<int>> &sol, vector<string> &v, string current_path, int m, int n){
        if(row==m-1 && col==n-1){
            sol[row][col]=1;
            v.push_back(current_path);
            sol[row][col]=0;
            return;
        }
        sol[row][col]=1;
        for(int i=0; i<4; i++){
            int nextX=row+dx[i];
            int nextY=col+dy[i];
            if(nextX>=0 && nextX<m && nextY>=0 && nextY<n && maze[nextX][nextY]==1 && sol[nextX][nextY]==0){
                ratandmice(nextX,nextY,maze,sol,v,current_path+directions[i],m,n);
            } 
        }
        sol[row][col]=0;
    }
    vector<string> ratInMaze(vector<vector<int>>& maze) {
        // code here
        int m=maze.size();
        int n=maze[0].size();
        vector<vector<int>> sol(m,vector<int>(n,0));
        vector<string> v;
        string current_path="";
        if(maze[0][0]==0 || maze[m-1][n-1]==0){
            cout<<"no solution exist"<<endl;
            return v;
        }
        ratandmice(0,0,maze,sol,v,current_path,m,n);
        sort(v.begin(), v.end());
        return v;
        }
};
COUNT INVERSIONS 
class Solution {
  public:
    void comp(vector<int> &arr, int s, int e, int &count){
        int i=s; 
        int mid=s+(e-s)/2;
        int j=mid+1;
        vector<int> temp;
        while(i<=mid && j<=e){
            if(arr[i]>arr[j]){
                temp.push_back(arr[j]);
                count=count+(mid - i + 1);
                j++;
            }else{
                temp.push_back(arr[i]);
                i++;
            }
        }
        while(i<=mid){
            temp.push_back(arr[i]);
            i++;
        }
        while(j<=e){
            temp.push_back(arr[j]);
            j++;
        }
        int k=0;
        for(int idx=s; idx<=e; idx++){
            arr[idx]=temp[k];
            k++;
        }
        return;
    }
    int left_right(vector<int> &arr, int s, int e, int &count){
        if(s>=e){
            return count;
        }
        int mid=s+(e-s)/2;
        left_right(arr,s,mid,count);
        left_right(arr,mid+1,e,count);
        comp(arr,s,e,count);
    }
    int inversionCount(vector<int> &arr) {
        // Code Here
        int count=0;
        left_right(arr,0,arr.size()-1,count);
        return count;
    }
};
KTH SMALLEST ELEMENT 
class Solution {
  public:
    int kthSmallest(vector<int> &arr, int k) {
        // code here
        sort(arr.begin(), arr.end());
        return arr[k-1];
    }
};
SEARCH IN ROTATED SORTED ARRAY 
class Solution {
  public:
    int search(vector<int>& arr, int key) {
        // Code Here
        int s=0;
        int e=arr.size()-1;
        int i=0;
        int mid;
        while(s<=e){
            mid=s+(e-s)/2;
            if(arr[mid]==key){
                return mid;
            }
            if(arr[s]<=arr[mid]){
                if(arr[s]<=key && key<=arr[mid]){
                    e=mid-1;
                }else{
                    s=mid+1;
                    }
            }else{
                if(arr[mid]<=key && key<=arr[e]){
                    s=mid+1;
                }else{
                    e=mid-1;
                    }
                }
                i++;
            }
            return -1;
        }
};
GENERATE ALL BINARY STRINGS 
class Solution {
  public:
    void helper_func(string &s, int i, int n, vector<string> &result){
    if(i==n){
        result.push_back(s);
        return;
    }
    s.push_back('0');
    helper_func(s,i+1,n,result);
    s.pop_back();
    s.push_back('1');
    helper_func(s,i+1,n,result);
    s.pop_back();
}
    vector<string> binstr(int n) {
        // code here
    vector<string> result;
    string s="";
    int i=0;
    helper_func(s,i,n,result);
    return result;
    }
};
N qUEEN PROBLEM
class Solution {
  public:
      bool canPlace(vector<vector<char>> &board, int row, int col, int n){
        //check for row
        for(int i=0; i<n; i++){
            if(board[row][i]=='Q'){
                return false;
            }
        }   
        //check for col
        for(int i=0; i<n; i++){
            if(board[i][col]=='Q'){
                return false;
            }
        }
        //check for upper left diagonal
        int i=row; int j=col;
        while(i>=0 && j>=0){
            if(board[i][j]=='Q'){
                return false;
            }
            i--; j--;
        }
        //check for upper right diagonal
        i=row; j=col;
        while(i>=0 && j<n){
            if(board[i][j]=='Q'){
                return false;
            }
            i--; j++;
        }
        return true;
    }
    void SolveNQueen(vector<vector<char>> &board, int n, int row, vector<vector<int>> &sol, vector<int> &current_config){
        if(row==n){
            sol.push_back(current_config);
            sort(sol.begin(), sol.end());
            return;
        }
        for(int pos=0; pos<n; pos++){
            if(canPlace(board, row, pos, n)==true){
                board[row][pos]='Q';
                current_config.push_back(pos+1);
                SolveNQueen(board,n,row+1,sol,current_config);
                board[row][pos]='.';
                current_config.pop_back();
            }
        }
    }
    vector<vector<int>> nQueen(int n) {
        // code here
        vector<vector<int>> sol;
        vector<int> current_config;
        vector<vector<char>> board(n,vector<char>(n,'.'));
        SolveNQueen(board,n,0,sol,current_config);
        return sol;
    }
    
    
};
